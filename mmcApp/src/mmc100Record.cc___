#define VERSION 1.0

#include <algorithm>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <list.h>
#include <ctype.h>
#include <alarm.h>
#include <dbDefs.h>
#include <callback.h>
#include <dbStaticLib.h>
#include <dbAccess.h>
#include <dbScan.h>
#include <recGbl.h>
#include <recSup.h>
#include <dbEvent.h>
#include <devSup.h>
#include <math.h>
#include <time.h>
#include <errlog.h>

#define GEN_SIZE_OFFSET
#include "mmc100Record.h"
#undef GEN_SIZE_OFFSET

#include "drvAsynIPPort.h"
#include "asynDriver.h"
#include "asynOctet.h"
#include "asynOctetSyncIO.h"

#include "epicsMessageQueue.h"
#include "epicsExport.h"

#include "mmc100.h"


/*** Forward references ***/


/*** Record Support Entry Table (RSET) functions ***/

static long init_record( dbCommon *precord, int pass );
static long process    ( dbCommon *precord           );


rset mmc100RSET =
{
    RSETNUMBER,
    NULL,
    NULL,
    (RECSUPFUN) init_record,
    (RECSUPFUN) process,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};

extern "C" { epicsExportAddress( rset, mmc100RSET ); }


static long send_n_recv( asynUser *pasynUser, int axis, char *cmd, char *rsp  );
static long read_status( asynUser *pasynUser, int axis                        );
static void handle_cmd ( asynUser *pasynUser, char *cmd, list<int> moving_new );
static void serial_io  ( asynUser *pasynUser                                  );


epicsMessageQueue *mmcCmd;
epicsMessageQueue *mmcRsp[99];


/*** Debugging ***/

volatile int mmc100RecordDebug = 0;

extern "C" { epicsExportAddress( int, mmc100RecordDebug ); }

using namespace std;


/******************************************************************************/
static long init_record( dbCommon *precord, int pass )
{
    mmc100Record      *prec = (mmc100Record *)precord;

    char               serialPort[80];
    asynUser          *pasynUser;
    static const char  output_terminator[] = "\r\r";
    static const char  input_terminator [] = "\n\r";

    asynStatus         asyn_rtn;
    long               status = 0;

    if ( pass > 0 ) return( status );

    mmcCmd = new epicsMessageQueue( prec->naxs*100, MAX_MSG_SIZE );
    for ( int im = 0; im < prec->naxs; im++ )
        mmcRsp[im] = new epicsMessageQueue( 100, MAX_MSG_SIZE );

    sprintf( serialPort, "%s TCP", prec->port );

    drvAsynIPPortConfigure              ( prec->asyn, serialPort, 0, 0, 0 );
    asyn_rtn = pasynOctetSyncIO->connect( prec->asyn, 0, &pasynUser, NULL );

    if ( asyn_rtn != asynSuccess )
        printf( "Failed to connect to port %s\n", prec->port );

    pasynOctetSyncIO->setOutputEos( pasynUser, output_terminator,
                                    strlen(output_terminator)     );
    pasynOctetSyncIO->setInputEos ( pasynUser, input_terminator,
                                    strlen(input_terminator)      );

    // flush any junk at input port - should not be any data yet
    pasynOctetSyncIO->flush( pasynUser );

    epicsThreadCreate( prec->name, epicsThreadPriorityMedium,
                       epicsThreadGetStackSize(epicsThreadStackMedium),
                       (EPICSTHREADFUNC)serial_io, (void *)pasynUser );

    return( status );
}

/******************************************************************************/
static long process( dbCommon *precord )
{
    return( 0 );
}

/******************************************************************************/
static long send_n_recv( asynUser *pasynUser, int axis, char *cmd, char *rsp )
{
    char          buf[MAX_MSG_SIZE];
    const double  timeout = 10.0;
    size_t        nwrite, nread = 0;
    int           it, coff, eomReason;
    asynStatus    asyn_rtn = asynError;

    printf( "Got command: %d, %s\n", strlen(cmd), cmd );
    sprintf( buf, "%c%s", '\r', cmd );

    pasynOctetSyncIO->flush( pasynUser );
    pasynOctetSyncIO->write( pasynUser, buf, strlen(buf)+2, timeout, &nwrite );

    if ( axis > 9 ) coff = 2;
    else            coff = 1;

    if ( (strncmp(cmd+coff, "RST", 3) == 0) || (strncmp(cmd+coff, "POS?", 4) == 0) )
    {                                                            // need to read
        for ( it = 0; it < 30; it++ )
        {
            nread = 0;

            pasynOctetSyncIO->flush( pasynUser );
            pasynOctetSyncIO->write( pasynUser, "\r", 3, timeout, &nwrite );

            asyn_rtn = pasynOctetSyncIO->read( pasynUser, rsp, MAX_MSG_SIZE,
                                               timeout, &nread, &eomReason );
            if ( nread == 3 )
            {
                printf( "Got: %s\n", rsp );
                break;
            }
        }

        if ( nread != 3 ) printf( "Failed to reset controller #%d\n", axis );
    }

    nread = 0;
    if ( cmd[strlen(cmd)-1] == '?' )
    {                                                            // need to read
        epicsThreadSleep( 1.0 );
        asyn_rtn = pasynOctetSyncIO->read( pasynUser, rsp, MAX_MSG_SIZE,
                                           timeout, &nread, &eomReason );

        mmcRsp[axis-1]->send( cmd, strlen(cmd) );

        printf( "Got response: %d, %s\n", nread, rsp );
        if ( (asyn_rtn != asynSuccess) || (nread <= 0) )
        {
            rsp[0] = '\0';
            nread  = 0;
        }
        else
            printf( "Got response: %s\n", rsp );
    }

    epicsThreadSleep( 0.1 );

    return( nread );
}

/******************************************************************************/
static long read_status( asynUser *pasynUser, int axis )   // return status byte
{
    char  cmd[MAX_MSG_SIZE], rsp[MAX_MSG_SIZE];
    int   mlen;
    long  status = 0;

    // read the status byte
    mlen   = sprintf( cmd, "%dSTA?", axis );
    status = send_n_recv( pasynUser, axis, cmd, rsp );

    // read the position
    mlen   = sprintf( cmd, "%dPOS?", axis );
    status = send_n_recv( pasynUser, axis, cmd, rsp );

    // send info to the axis record
    mmcRsp[axis-1]->send( cmd, mlen );

    return( status );
}

/******************************************************************************/
static void handle_cmd( asynUser *pasynUser, char *cmd, list<int> moving_new )
{
    char  rsp[MAX_MSG_SIZE];
    int   axis, coff;
    long  status = OK;

    printf( "Got command: %d, %s\n", strlen(cmd), cmd );
    status = sscanf( cmd, "%d", &axis );
    if ( (status == 1) && (axis >= 1) && (axis <= 99) )
    {
        if ( axis > 9 ) coff = 2;
        else            coff = 1;

        if ( strncmp(cmd+coff, "STUP", 4) == 0 )
            status = read_status( pasynUser, axis );
        else
        {
            status = send_n_recv( pasynUser, axis, cmd, rsp );

            if ( strncmp(cmd+coff, "MV", 2) == 0 )
                moving_new.push_back( axis );
        }
    }
    else 
        printf( "Bad command\n" );

    return;
}

/******************************************************************************/
static void serial_io( asynUser *pasynUser )
{
    char                 cmd[MAX_MSG_SIZE];
    list<int>            moving, moving_new;
    list<int>::iterator  ia;
    int                  mlen;
    long                 status = OK;

    while ( ! interruptAccept ) epicsThreadSleep( 1 );

    while ( 1 )
    {
        if ( moving.size() == 0 )                           // no axis is moving
        {
            while ( (mlen = mmcCmd->tryReceive(cmd, MAX_MSG_SIZE)) > 0 )
            {
                cmd[mlen] = '\0';
                handle_cmd( pasynUser, cmd, moving_new );
            }

            mlen = mmcCmd->receive( cmd, MAX_MSG_SIZE );
            if ( mlen > 0 )
            {
                cmd[mlen] = '\0';
                handle_cmd( pasynUser, cmd, moving_new );
            }
            else 
                printf( "Bad command\n" );
        }
        else
        {
            for ( ia = moving.begin(); ia != moving.end(); ia++ )
            {
                // read the status
                status = read_status( pasynUser, *ia );
                if ( status & 8 ) moving.erase( ia );          // motion stopped

                while ( (mlen = mmcCmd->tryReceive(cmd, MAX_MSG_SIZE)) > 0 )
                {
                    cmd[mlen] = '\0';
                    handle_cmd( pasynUser, cmd, moving_new );
                }
            }
        }

        // merge old and new moving lists
        moving.splice( moving.begin(), moving_new );
    }
}

