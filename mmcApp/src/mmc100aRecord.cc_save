#define VERSION 1.0

#include <algorithm>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <alarm.h>
#include <dbDefs.h>
#include <callback.h>
#include <dbStaticLib.h>
#include <dbAccess.h>
#include <dbScan.h>
#include <recGbl.h>
#include <recSup.h>
#include <dbEvent.h>
#include <devSup.h>
#include <math.h>
#include <time.h>
#include <errlog.h>

#define GEN_SIZE_OFFSET
#include "mmc100aRecord.h"
#undef GEN_SIZE_OFFSET

#include "drvAsynSerialPort.h"
#include "asynDriver.h"
#include "asynOctet.h"
#include "asynOctetSyncIO.h"

#include "epicsExport.h"

#include "mmc100.h"


/*** Forward references ***/


/*** Record Support Entry Table (RSET) functions ***/

static long init_record( dbCommon *precord, int pass  );
static long process    ( dbCommon *precord            );
static long special    ( dbAddr   *pDbAddr, int after );
static long cvt_dbaddr ( dbAddr   *pDbAddr            );


rset mmc100aRSET =
{
    RSETNUMBER,
    NULL,
    NULL,
    (RECSUPFUN) init_record,
    (RECSUPFUN) process,
    (RECSUPFUN) special,
    NULL,
    (RECSUPFUN) cvt_dbaddr,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};

extern "C" { epicsExportAddress( rset, mmc100aRSET ); }


#define MIP_DONE     0x0000    // No motion is in progress
#define MIP_MOVE     0x0001    // A move not resulting from Jog* or Hom*
#define MIP_RETRY    0x0002    // A retry is in progress
#define MIP_NEW      0x0004    // Stop current move for a new move
#define MIP_BL       0x0008    // Done moving, now take out backlash
#define MIP_HOMF     0x0010    // A home-forward command is in progress
#define MIP_HOMR     0x0020    // A home-reverse command is in progress
#define MIP_HOMB     0x0040    // Back off from the limit switch
#define MIP_HOMC     0x0080    // Creep to the limit switch
#define MIP_HOME     (MIP_HOMF | MIP_HOMR)
#define MIP_JOGF     0x0100    // Jog forward
#define MIP_JOGR     0x0200    // Jog backward
#define MIP_JOG      (MIP_JOGF | MIP_JOGR)
#define MIP_CAL1     0x0400    // Calibration step 1
#define MIP_CAL2     0x0800    // Calibration step 2
#define MIP_CAL3     0x0B00    // Calibration step 3
#define MIP_PAUSE    0x1000    // Move is being paused
#define MIP_STOP     0x8000    // We're trying to stop.  If a home command
                               // is issued when the motor is moving, we
                               // stop the motor first

#define MAX_MSG_SIZE 61

#define OK            0


static long connect_motor     ( mmc100aRecord *precord                          );
static long init_motor        ( mmc100aRecord *precord                          );
static void new_move          ( mmc100aRecord *precord                          );
static void do_move           ( mmc100aRecord *precord                          );
static void post_fields       ( mmc100aRecord *precord, unsigned short alarm_mask,
                                                      unsigned short all      );

static long send_and_recv     ( struct mmc100a_info *mInfo, char const *msg,
                                                          char *rbbuf         );

static void update_status     ( struct mmc100a_info *mInfo                      );
static void checkStatus       ( struct mmc100a_info *mInfo                      );

static long log_msg  ( mmc100aRecord *prec, int dlvl, const char *fmt, ... );
static void post_msgs( mmc100aRecord *prec                                 );


MsgQueue *mmcMsg;


/*** Debugging ***/

volatile int mmc100aRecordDebug = 0;

extern "C" { epicsExportAddress( int, mmc100aRecordDebug ); }

using namespace std;


/******************************************************************************/
static long init_record( dbCommon *precord, int pass )
{
    mmc100aRecord *prec = (mmc100aRecord *)precord;
    mmc100a_info  *mInfo;

    long         status = 0;

    if ( pass > 0 ) return( status );

    mmcMsg = new MsgQueue();

    mInfo = (mmc100a_info *)malloc( sizeof(mmc100a_info) );
    mInfo->precord   = prec;
    mInfo->uEvent    = new epicsEvent( epicsEventEmpty );
    mInfo->uMutex    = new epicsMutex();

    mInfo->newData   = 0;

    mInfo->lMutex    = new epicsMutex();
    mInfo->mLength   = 61;
    mInfo->cIndex    = 0;
    mInfo->newMsg    = 0;
    mInfo->sAddr     = (char *)calloc( 8*61, sizeof(char) );

    prec->loga       = mInfo->sAddr;
    prec->logb       = mInfo->sAddr + mInfo->mLength * 1;
    prec->logc       = mInfo->sAddr + mInfo->mLength * 2;
    prec->logd       = mInfo->sAddr + mInfo->mLength * 3;
    prec->loge       = mInfo->sAddr + mInfo->mLength * 4;
    prec->logf       = mInfo->sAddr + mInfo->mLength * 5;
    prec->logg       = mInfo->sAddr + mInfo->mLength * 6;
    prec->logh       = mInfo->sAddr + mInfo->mLength * 7;

    prec->dpvt       = mInfo;

    gethostname( prec->host, 60                   );
    strcpy     ( prec->iocn, getenv("EPICS_NAME") );

    connect_motor ( prec );
    init_motor    ( prec );

    return( status );
}

/******************************************************************************/
static long connect_motor( mmc100aRecord *prec )
{
    mmc100a_info        *mInfo = (mmc100a_info *)prec->dpvt;

    asynUser          *pasynUser;
    static const char  output_terminator[] = "\0";
    static const char  input_terminator [] = "\0";

    asynStatus         asyn_rtn;
    motor_status       msta;

    int                status = 0;

    msta.All = 0;

    mInfo->uMutex->lock();

    drvAsynSerialPortConfigure          ( prec->asyn, prec->usb, 0, 0, 0  );
    asyn_rtn = pasynOctetSyncIO->connect( prec->asyn, 0, &pasynUser, NULL );

    if ( asyn_rtn != asynSuccess )
    {
        log_msg( prec, 0, "Failed to connect to the port" );

        msta.Bits.RA_COMM_ERR = 1;
    }

//  pasynOctetSyncIO->setOutputEos( pasynUser, output_terminator,
//                                  strlen(output_terminator)     );
//  pasynOctetSyncIO->setInputEos ( pasynUser, input_terminator,
//                                  strlen(input_terminator)      );

    // flush any junk at input port - should not be any data yet
    pasynOctetSyncIO->flush( pasynUser );

    mInfo->pasynUser = pasynUser;

    mInfo->uMutex->unlock();

    callbackSetCallback( (void (*)(struct callbackPvt *)) update_status,
                         &(mInfo->callback) );
    callbackSetPriority( priorityMedium, &(mInfo->callback) );

    epicsThreadCreate  ( prec->name, epicsThreadPriorityMedium,
                         epicsThreadGetStackSize(epicsThreadStackMedium),
                         (EPICSTHREADFUNC)checkStatus, (void *)mInfo );

    return( status );
}

/******************************************************************************/
static long init_motor( mmc100aRecord *prec )
{
    mmc100a_info       *mInfo = (mmc100a_info *)prec->dpvt;

    char              msg[MAX_MSG_SIZE], rbbuf[MAX_MSG_SIZE];
    int               retry, status = 0;
    epicsUInt32       old_msta = prec->msta;
    motor_status      msta;
    unsigned short    alarm_mask;

    mInfo->uMutex->lock();

    msta.All           =  0;
    msta.Bits.NOT_INIT =  1;

    mInfo->init        = -1;

    // read the device ID
    retry = 1;
    do
    {
        status = send_and_recv( mInfo, "DN", rbbuf );
        if ( (status > 0) && (strlen(rbbuf) > 3) )
        {
            strncpy( prec->dn,   rbbuf, 8 );
            db_post_events( prec,  prec->dn  , DBE_VAL_LOG );
        }
        else
            status = 0;

        epicsThreadSleep( 0.2 );
    } while ( (status <= 0) && (retry++ < 3) );

    if ( status <= 0 )
    {
        log_msg( prec, 0, "Failed to read the device ID" );

        msta.Bits.RA_COMM_ERR = 1;
        goto finished;
    }

    // read the firmware version
    retry = 1;
    do
    {
        status = send_and_recv( mInfo, "VER", rbbuf );
        if ( (status > 0) && (strlen(rbbuf) > 3) )
        {
            strncpy( prec->fver, rbbuf, 8 );
            db_post_events( prec,  prec->fver, DBE_VAL_LOG );
        }
        else
            status = 0;

        epicsThreadSleep( 0.2 );
    } while ( (status <= 0) && (retry++ < 3) );

    if ( status <= 0 )
    {
        log_msg( prec, 0, "Failed to read the firmware version" );

        msta.Bits.RA_COMM_ERR = 1;
        goto finished;
    }

    // set the parameters
    sprintf( msg, "DO=%d",   prec->dout );
    send_and_recv( mInfo, msg, rbbuf );

    epicsThreadSleep( 0.1 );

    sprintf( msg, "EO=%d",   prec->eo   );
    send_and_recv( mInfo, msg, rbbuf );

    epicsThreadSleep( 0.1 );

    sprintf( msg, "POL=%d",  prec->encm*256 +
                             prec->pol4*16  + prec->pol1*2 + prec->pol0 );
    send_and_recv( mInfo, msg, rbbuf );

    epicsThreadSleep( 0.1 );

    sprintf( msg, "SCV=%d",  prec->scv  );
    send_and_recv( mInfo, msg, rbbuf );

    epicsThreadSleep( 0.1 );

    sprintf( msg, "SL=%d",   prec->sl   );
    send_and_recv( mInfo, msg, rbbuf );

    epicsThreadSleep( 0.1 );

    sprintf( msg, "SLT=%d",  prec->slt  );
    send_and_recv( mInfo, msg, rbbuf );

    epicsThreadSleep( 0.1 );

    sprintf( msg, "SLE=%d",  prec->sle  );
    send_and_recv( mInfo, msg, rbbuf );

    epicsThreadSleep( 0.1 );

    sprintf( msg, "SLA=%d",  prec->sla  );
    send_and_recv( mInfo, msg, rbbuf );

    epicsThreadSleep( 0.1 );

    if ( (prec->accl < 1) || (prec->accl >    5000) ) prec->accl =    1000;
    sprintf( msg, "ACC=%d",  prec->accl );
    send_and_recv( mInfo, msg, rbbuf );

    epicsThreadSleep( 0.1 );

    if ( (prec->vbas < 1) || (prec->vbas > 6000000) ) prec->vbas =    5000;
    if ( (prec->vmax < 1) || (prec->vmax > 6000000) ) prec->vmax = 1000000;
    if ( prec->vbas > prec->vmax ) prec->vbas = prec->vmax;
    sprintf( msg, "LSPD=%ld", prec->vbas );
    send_and_recv( mInfo, msg, rbbuf );

    epicsThreadSleep( 0.1 );

    sprintf( msg, "HSPD=%ld", prec->vmax );
    send_and_recv( mInfo, msg, rbbuf );

    // make sure the limits are consistent
    if ( prec->dir == mmc100aDIR_Positive )
    {
        prec->dllm = prec->llm - prec->off;
        prec->dhlm = prec->hlm - prec->off;
    }
    else
    {
        prec->dllm = prec->off - prec->hlm;
        prec->dhlm = prec->off - prec->llm;
    }

    prec->dmov   = 1;
    prec->mip    = MIP_DONE;

    mInfo->init  = 0;

    finished:
    mInfo->uMutex->unlock();

    if      ( msta.Bits.RA_COMM_ERR )                                // hardware
        recGblSetSevr( (dbCommon *)prec, COMM_ALARM,  INVALID_ALARM );
    else if ( msta.Bits.NOT_INIT    )                                // NOT_INIT
    {
        recGblSetSevr( (dbCommon *)prec, STATE_ALARM, MAJOR_ALARM   );

        log_msg( prec, 0, "Wait for first status update" );
    }

    prec->msta = msta.All;

    if ( old_msta != prec->msta ) MARK( M_MSTA );

    recGblGetTimeStamp( prec );

    alarm_mask = recGblResetAlarms( prec );
    post_fields( prec, alarm_mask, 1 );
    post_msgs  ( prec                );

    prec->poll = 1;
    mInfo->uEvent->signal();

    return( 0 );
}

/******************************************************************************/
static long process( dbCommon *precord )
{
    mmc100aRecord    *prec = (mmc100aRecord *)precord;
    mmc100a_info     *mInfo = (mmc100a_info *)prec->dpvt;
    char            msg[MAX_MSG_SIZE], rbbuf[MAX_MSG_SIZE], old_sls[16];
    unsigned short  old_mip,  alarm_mask;
    short           old_movn = prec->movn, old_dmov, old_rcnt, old_miss;
    double          old_val,  old_dval, old_drbv, old_rbv, old_diff, diff;
    long            old_px, old_rval, old_rrbv, old_velo, status = OK;
    motor_status    old_msta, msta;
    timespec        ts;
    bool            first;

    if ( prec->pact ) return( OK );

    prec->pact = 1;
    log_msg( prec, 1, "Process" );

    mInfo->uMutex->lock();
    if ( mInfo->newData == 0 )
    {
        mInfo->uMutex->unlock();
        goto exit;
    }

    strncpy( old_sls, prec->sls, 16 );

    old_msta.All = prec->msta;
    msta.All     = 0;

    if ( (mInfo->mst == -1) && (mInfo->sls == -1) )
    {
        msta.Bits.RA_COMM_ERR = 1;
        msta.Bits.NOT_INIT    = 1;

        mInfo->init    = -1;
        mInfo->newData =  0;
        mInfo->uMutex->unlock();
        goto finished;
    }
    else if ( mInfo->init == -1 )
    {
        msta.Bits.NOT_INIT    = 1;

        mInfo->newData = 0;
        mInfo->uMutex->unlock();
        goto finished;
    }

    if ( prec->sl == mmc100aAble_Enable )
    {
        if      ( mInfo->sls ==  0 ) strcpy( prec->sls, "Idle"          );
        else if ( mInfo->sls ==  1 ) strcpy( prec->sls, "Moving"        );
        else if ( mInfo->sls ==  2 ) strcpy( prec->sls, "Correcting"    );
        else if ( mInfo->sls ==  3 ) strcpy( prec->sls, "Stopping"      );
        else if ( mInfo->sls ==  4 ) strcpy( prec->sls, "Jogging"       );
        else if ( mInfo->sls ==  5 ) strcpy( prec->sls, "Homing"        );
        else if ( mInfo->sls ==  6 ) strcpy( prec->sls, "No6"           );
        else if ( mInfo->sls ==  7 ) strcpy( prec->sls, "No7"           );
        else if ( mInfo->sls ==  8 ) strcpy( prec->sls, "No8"           );
        else if ( mInfo->sls ==  9 ) strcpy( prec->sls, "No9"           );
        else if ( mInfo->sls == 10 ) strcpy( prec->sls, "Cor Range Err" );
        else if ( mInfo->sls == 11 ) strcpy( prec->sls, "Cor Attm Err"  );
        else if ( mInfo->sls == 12 ) strcpy( prec->sls, "Not Activated" );

        if ( (mInfo->sls > 0) && (mInfo->sls < 10) ) prec->movn = 1;
        else                                         prec->movn = 0;

        if ( mInfo->sls > 9 )
        {
            msta.Bits.RA_ERR = mInfo->sls;
            if      ( mInfo->sls == 10 ) log_msg( prec, 0, "Cor Range Err" );
            else if ( mInfo->sls == 11 ) log_msg( prec, 0, "Cor Attm Err"  );
            else if ( mInfo->sls == 12 ) log_msg( prec, 0, "Not Activated" );
        }
    }
    else
    {
        strcpy( prec->sls, "Not Activated" );

        if ( (mInfo->mst & 7) > 0                  ) prec->movn = 1;
        else                                         prec->movn = 0;
    }

    if ( strncmp(old_sls, prec->sls, 16) != 0 ) MARK( M_SLS  );
    if ( old_movn != prec->movn               ) MARK( M_MOVN );

    msta.Bits.RA_MOVING = prec->movn;

    first = ! mInfo->init;
    if ( first )
    {
        mInfo->init = 1;

        prec->poll  = 0;
        log_msg( prec, 0, "Initialization completed" );
    }

    if ( mInfo->newData == 9 )
    {
        old_px   = prec->px  ;
        old_rrbv = prec->rrbv;
        old_drbv = prec->drbv;
        old_rbv  = prec->rbv ;
        old_velo = prec->velo;

        if ( (prec->sds > 0) && (prec->sdd > 0) )             // check for stall
        {
            clock_gettime( CLOCK_REALTIME, &ts );
            if ( (prec->mip == MIP_DONE) || (prec->mip & MIP_PAUSE) )
                prec->msec = ts.tv_sec;
            else
            {
                if ( labs(mInfo->ex - prec->rrbv) > prec->sdd )
                    prec->msec = ts.tv_sec;
                else if ( labs(ts.tv_sec - prec->msec) > prec->sds )
                {
                    msta.Bits.RA_STALL = 1;
                    log_msg( prec, 0, "Stall detected" );
                }
            }
        }

        prec->px   = mInfo->px;
        prec->rrbv = mInfo->ex;
        prec->drbv = prec->rrbv * prec->eres;
        prec->rbv  = (1. - 2.*prec->dir) * prec->drbv + prec->off;
        prec->velo = mInfo->ps;

        if ( old_px   != prec->px   ) MARK( M_PX   );
        if ( old_rrbv != prec->rrbv ) MARK( M_RRBV );
        if ( old_drbv != prec->drbv ) MARK( M_DRBV );
        if ( old_rbv  != prec->rbv  ) MARK( M_RBV  );
        if ( old_velo != prec->velo ) MARK( M_VELO );
    }

    mInfo->newData = 0;
    mInfo->uMutex->unlock();

    if ( prec->movn )                                            // still moving
    {
        if ( msta.Bits.RA_STALL == 1 )
        {
            send_and_recv( mInfo, "STOP", rbbuf );
            prec->mip  |=  MIP_STOP ;
        }

        goto finished;
    }

    if ( prec->mip == MIP_DONE )             // was not moving, check slip_stall
    {
        old_diff   = prec->diff;
        prec->diff = prec->rbv - prec->val;

        if ( fabs(prec->diff) > prec->pdbd )
        {
            log_msg( prec, 0, "Slipped, diff = %.6g", prec->diff );
            msta.Bits.EA_SLIP_STALL = 1;
        }

        if ( old_diff != prec->diff ) MARK( M_DIFF );

        goto finished;
    }

    old_mip  = prec->mip ;
    old_dmov = prec->dmov;
    old_rcnt = prec->rcnt;
    old_miss = prec->miss;
    old_val  = prec->val ;
    old_dval = prec->dval;
    old_rval = prec->rval;

    diff = prec->rbv - prec->val;

    if ( prec->mip & (MIP_STOP | MIP_PAUSE) )                   // stop or pause
    {
        short newval = 1;

        prec->rcnt = 0;
        prec->poll = 0;

        if      ( prec->mip & MIP_STOP  )
        {
            if ( msta.Bits.RA_STALL == 1 )
            {
                prec->msec = ts.tv_sec;

                if ( prec->mip & (MIP_CAL1 || MIP_CAL2) )
                {
                    log_msg( prec, 0, "Calibration aborted due to stall," );
                    log_msg( prec, 0, "back to original position" );

                    sprintf( msg, "SL=%d", prec->osl );
                    send_and_recv( mInfo, msg, rbbuf );

                    prec->sl   = prec->osl;
                    db_post_events( prec, &prec->sl,   DBE_VAL_LOG );

                    prec->dval = prec->oex * prec->eres;
                    prec->val  = (1. - 2.*prec->dir) * prec->dval + prec->off;

                    new_move( prec );

                    newval = 0;
                }
                else if ( prec->mip & MIP_JOG )
                    log_msg( prec, 0, "Stopped jogging due to stall" );
                else
                    log_msg( prec, 0, "Stopped moving due to stall"  );
            }
            else if ( prec->mip & MIP_JOG )
                log_msg( prec, 0, "Stopped jogging"     );
            else
                log_msg( prec, 0, "Stopped moving at %.6g (DVAL: %.6g)",
                                  prec->rbv, prec->drbv );

            prec->miss = 0;
        }
        else if ( prec->mip & MIP_PAUSE )
        {
            if ( prec->mip & MIP_JOG )
                log_msg( prec, 0, "Paused jogging"      );
            else
                log_msg( prec, 0, "Paused moving at %.6g (DVAL: %.6g)",
                                  prec->rbv, prec->drbv );

            newval = 0;
        }

        if ( newval )
        {
            prec->mip  = MIP_DONE;
            prec->dmov = 1;
            prec->val  = prec->rbv;
            prec->dval = prec->drbv;
            prec->rval = prec->rrbv;
            prec->diff = 0;
        }
    }
    else if ( prec->mip == MIP_CAL1 )
    {
        if ( prec->calf == 1 )
        {
            prec->slrf = prec->calp / fabs(prec->rrbv - prec->oex);
            db_post_events( prec, &prec->slrf, DBE_VAL_LOG );
        }
        else
        {
            prec->slrr = prec->calp / fabs(prec->rrbv - prec->oex);
            db_post_events( prec, &prec->slrr, DBE_VAL_LOG );
        }

        prec->nex  = prec->rrbv;
        send_and_recv( mInfo, "X0", rbbuf );

        prec->mip  = MIP_CAL2;
        if ( prec->calf == 1 )
            log_msg( prec, 0, "Continue calibration, rev" );
        else
            log_msg( prec, 0, "Continue calibration, fwd" );
    }
    else if ( prec->mip == MIP_CAL2 )
    {
        if ( prec->calf == 1 )
        {
            prec->calf = 0;

            prec->slrr = prec->calp / fabs(prec->rrbv - prec->nex);
            db_post_events( prec, &prec->slrr, DBE_VAL_LOG );
        }
        else
        {
            prec->calr = 0;

            prec->slrf = prec->calp / fabs(prec->rrbv - prec->nex);
            db_post_events( prec, &prec->slrf, DBE_VAL_LOG );
        }

        log_msg( prec, 0, "Calibration finished, back to original position" );

        sprintf( msg, "SL=%d", prec->osl );
        send_and_recv( mInfo, msg, rbbuf );

        prec->sl   = prec->osl;
        db_post_events( prec, &prec->sl,   DBE_VAL_LOG );

        prec->dval = prec->oex * prec->eres;
        prec->val  = (1. - 2.*prec->dir) * prec->dval + prec->off;

        new_move( prec );
    }
    else if ( prec->mip == MIP_NEW ) new_move( prec );
    else if ( (fabs(diff) >= prec->rdbd) &&                 // not closed enough
              (prec->rtry > 0) && (prec->rcnt < prec->rtry) )  // can retry more
    {
        prec->mip  |= MIP_RETRY;

        log_msg( prec, 0, "Desired %.6g, reached %.6g, retrying %d ...",
                          prec->val,  prec->rbv,  ++prec->rcnt );

        do_move( prec );
    }
    else                             // close enough, or no (more) retry allowed
    {
        prec->diff = diff;
        if ( fabs(diff) < prec->rdbd )
        {
            log_msg( prec, 0, "Desired %.6g, reached %.6g",
                              prec->val, prec->rbv             );
            prec->miss = 0;
        }
        else
        {
            log_msg( prec, 0, "Desired %.6g, reached %.6g after %d retries",
                              prec->val, prec->rbv, prec->rcnt );
            prec->miss = 1;
        }

        prec->mip  = MIP_DONE;
        prec->dmov = 1;
        prec->rcnt = 0;
        prec->poll = 0;
    }

    if ( old_mip  != prec->mip  ) MARK( M_MIP  );
    if ( old_dmov != prec->dmov ) MARK( M_DMOV );
    if ( old_rcnt != prec->rcnt ) MARK( M_RCNT );
    if ( old_miss != prec->miss ) MARK( M_MISS );
    if ( old_val  != prec->val  ) MARK( M_VAL  );
    if ( old_dval != prec->dval ) MARK( M_DVAL );
    if ( old_rval != prec->rval ) MARK( M_RVAL );

    finished:
    if      ( msta.Bits.RA_COMM_ERR                       )          // hardware
    {
        recGblSetSevr( (dbCommon *)prec, COMM_ALARM,  INVALID_ALARM );

        log_msg( prec, 0, "Cannot reach the controller" );
    }
    else if ( msta.Bits.NOT_INIT                          )          // NOT_INIT
    {
        recGblSetSevr( (dbCommon *)prec, STATE_ALARM, MAJOR_ALARM   );

        log_msg( prec, 0, "Please re-initialize"        );
    }
    else if ( msta.Bits.RA_ERR || msta.Bits.RA_STALL || msta.Bits.EA_SLIP_STALL)
    {
        recGblSetSevr( (dbCommon *)prec, STATE_ALARM, MINOR_ALARM   );
    }
    else if ( ! first )
    {
        if ( prec->sevr > NO_ALARM )                // had alarm/warnings before
            log_msg( prec, 0, "Alarm/warnings cleared" );
    }

    prec->msta = msta.All;
    if ( prec->msta != old_msta.All ) MARK( M_MSTA );

    recGblGetTimeStamp( prec );

    alarm_mask = recGblResetAlarms( prec );
    post_fields( prec, alarm_mask, 0 );
    post_msgs  ( prec                );

    recGblFwdLink     ( prec );                 // process the forward scan link

    exit:
    prec->proc = 0;
    prec->pact = 0;

    return( status );
}

/******************************************************************************/
static void new_move( mmc100aRecord *prec )
{
    log_msg( prec, 0, "Move to %.6g (DVAL: %.6g)", prec->val, prec->dval );

    prec->dmov = 0;
    prec->mip  = MIP_MOVE;
    prec->rval = NINT(prec->dval / prec->eres);

    do_move( prec );

    return;
}

/******************************************************************************/
static void do_move( mmc100aRecord *prec )
{
    mmc100a_info     *mInfo = (mmc100a_info *)prec->dpvt;
    char            msg[MAX_MSG_SIZE], rbbuf[MAX_MSG_SIZE];
    long            px_des;

    if ( mInfo->sls > 9 )                               // clear the error first
    {
        send_and_recv( mInfo, "ABORT", rbbuf );

        epicsThreadSleep( 0.1 );
    }

    if ( prec->sl == mmc100aAble_Enable )
    {
        // set the SLR according to the direction
        if ( prec->dir == mmc100aDIR_Positive )
        {
            if ( prec->rval > prec->rrbv ) sprintf( msg, "SLR=%f", prec->slrf );
            else                           sprintf( msg, "SLR=%f", prec->slrr );
        }
        else
        {
            if ( prec->rval > prec->rrbv ) sprintf( msg, "SLR=%f", prec->slrr );
            else                           sprintf( msg, "SLR=%f", prec->slrf );
        }
        send_and_recv( mInfo, msg, rbbuf );

        epicsThreadSleep( 0.1 );

        // send the move command
        sprintf( msg, "X%ld", prec->rval );
        send_and_recv( mInfo, msg, rbbuf );
    }
    else
    {
        if ( prec->dir == mmc100aDIR_Positive )
        {
            if ( prec->rval > prec->rrbv )
                px_des = prec->px + (prec->rval - prec->rrbv) * prec->slrf + .5;
            else
                px_des = prec->px + (prec->rval - prec->rrbv) * prec->slrr + .5;
        }
        else
        {
            if ( prec->rval > prec->rrbv )
                px_des = prec->px + (prec->rval - prec->rrbv) * prec->slrr + .5;
            else
                px_des = prec->px + (prec->rval - prec->rrbv) * prec->slrf + .5;
        }

        sprintf( msg, "X%ld", px_des     );
        send_and_recv( mInfo, msg, rbbuf );
    }

    prec->poll = 1;
    mInfo->uEvent->signal();

    return;
}

/******************************************************************************/
static long special( dbAddr *pDbAddr, int after )
{
    mmc100aRecord    *prec = (mmc100aRecord *)pDbAddr->precord;
    mmc100a_info     *mInfo = (mmc100a_info *)prec->dpvt;
    char            msg[MAX_MSG_SIZE], rbbuf[MAX_MSG_SIZE];
    long            old_px, old_rval, new_px;
    short           old_dmov, old_rcnt, old_lvio;
    double          nval, old_val, old_dval, old_rbv, new_dval;
    unsigned short  old_mip, alarm_mask = 0;
    motor_status    msta;

    int             fieldIndex = dbGetFieldIndex( pDbAddr );
    int             status = OK;

    if ( after == 0 )
    {
        if      ( fieldIndex == mmc100aRecordVAL  ) prec->oval = prec->val ;
        else if ( fieldIndex == mmc100aRecordDVAL ) prec->oval = prec->dval;
        else if ( fieldIndex == mmc100aRecordSPG  ) prec->oval = prec->spg ;
        else if ( fieldIndex == mmc100aRecordDIR  ) prec->oval = prec->dir ;
        else if ( fieldIndex == mmc100aRecordOFF  ) prec->oval = prec->off ;
        else if ( fieldIndex == mmc100aRecordSET  ) prec->oval = prec->set ;
        else if ( fieldIndex == mmc100aRecordLLM  ) prec->oval = prec->llm ;
        else if ( fieldIndex == mmc100aRecordHLM  ) prec->oval = prec->hlm ;
        else if ( fieldIndex == mmc100aRecordDLLM ) prec->oval = prec->dllm;
        else if ( fieldIndex == mmc100aRecordDHLM ) prec->oval = prec->dhlm;
        else if ( fieldIndex == mmc100aRecordERES ) prec->oval = prec->eres;

        return( OK );
    }

    old_val  = prec->val ;
    old_dval = prec->dval;
    old_rval = prec->rval;
    old_px   = prec->px  ;
    old_rbv  = prec->rbv ;
    old_mip  = prec->mip ;
    old_dmov = prec->dmov;
    old_rcnt = prec->rcnt;
    old_lvio = prec->lvio;

    msta.All = prec->msta;

    switch( fieldIndex )
    {
        case mmc100aRecordVAL :
            if ( (prec->sevr >  MINOR_ALARM) ||
                 ((prec->set == mmc100aSET_Use) && (prec->spg != mmc100aSPG_Go)) )
            {
                prec->val  = prec->oval;

                if      ( msta.Bits.RA_COMM_ERR    )
                    log_msg( prec, 0, "No move/set, hardware problem"  );
                else if ( msta.Bits.NOT_INIT       )
                    log_msg( prec, 0, "No move/set, init not finished" );
                else if ( prec->spg != mmc100aSPG_Go )
                    log_msg( prec, 0, "No move, SPG is not Go"         );
                else
                    log_msg( prec, 0, "No move/set, unknown alarm"     );

                break;
            }

            new_dval = (prec->val - prec->off) * (1. - 2.*prec->dir);
            if ( (prec->val < prec->llm) || (prec->val > prec->hlm) )
            {                                    // violated the software limits
                prec->lvio = 1;                     // set limit violation alarm
                prec->val  = prec->oval;

                log_msg( prec, 0, "No move/set, limit violated" );
                break;
            }

            do_move1:
            if ( prec->set == mmc100aSET_Use )            // do it only when "Use"
                prec->dval = new_dval;

            goto do_move2;
        case mmc100aRecordDVAL:
            if ( (prec->sevr >  MINOR_ALARM) ||
                 ((prec->set == mmc100aSET_Use) && (prec->spg != mmc100aSPG_Go)) )
            {
                prec->dval = prec->oval;

                if      ( msta.Bits.RA_COMM_ERR    )
                    log_msg( prec, 0, "No move/set, hardware problem"  );
                else if ( msta.Bits.NOT_INIT       )
                    log_msg( prec, 0, "No move/set, init not finished" );
                else if ( prec->spg != mmc100aSPG_Go )
                    log_msg( prec, 0, "No move, SPG is not Go"         );
                else
                    log_msg( prec, 0, "No move/set, unknown alarm"     );

                break;
            }

            if ( (prec->dval < prec->dllm) || (prec->dval > prec->dhlm) )
            {                                    // violated the hardware limits
                prec->lvio = 1;                     // set limit violation alarm
                prec->dval = prec->oval;

                log_msg( prec, 0, "No move/set, limit violated" );
                break;
            }

            prec->val  = prec->dval * (1. - 2.*prec->dir) + prec->off;

            do_move2:
            if ( prec->set == mmc100aSET_Set ) break;                   // no move

            prec->lvio = 0;
            prec->rcnt = 0;

            if ( prec->dmov == 0 )                               // still moving
            {
                if ( prec->mip != MIP_NEW )           // stop current move first
                {
                    log_msg( prec, 0, "Stop current move" );
                    prec->mip  = MIP_NEW;

                    send_and_recv( mInfo, "STOP", rbbuf );
                }

                break;
            }

            new_move( prec );

            break;
        case mmc100aRecordTWF :
            nval = prec->val + prec->twv;
            goto tweak;
        case mmc100aRecordTWR :
            nval = prec->val - prec->twv;

            tweak:
            if ( (prec->sevr > MINOR_ALARM) || (prec->spg != mmc100aSPG_Go) )
            {
                if      ( msta.Bits.RA_COMM_ERR    )
                    log_msg( prec, 0, "No tweak, hardware problem"  );
                else if ( msta.Bits.NOT_INIT       )
                    log_msg( prec, 0, "No tweak, init not finished" );
                else if ( prec->spg != mmc100aSPG_Go )
                    log_msg( prec, 0, "No tweak, SPG is not Go"     );
                else
                    log_msg( prec, 0, "No tweak, unknown alarm"     );

                break;
            }

            new_dval = (nval - prec->off) * (1. - 2.*prec->dir);
            if ( (nval < prec->llm) || (nval > prec->hlm) )
            {                                    // violated the software limits
                prec->lvio = 1;                     // set limit violation alarm
                log_msg( prec, 0, "No tweak, limit violated" );

                break;
            }

            prec->val = nval;
            goto do_move1;
        case mmc100aRecordJOGF:
            if ( prec->jogf == 0 )
            {
                if ( prec->mip == MIP_JOGF )
                {
                    prec->mip |= MIP_STOP;
                    send_and_recv( mInfo, "STOP", rbbuf );
                }

                break;
            }

            goto jogging_or_not;
        case mmc100aRecordJOGR:
            if ( prec->jogr == 0 )
            {
                if ( prec->mip == MIP_JOGR )
                {
                    prec->mip |= MIP_STOP;
                    send_and_recv( mInfo, "STOP", rbbuf );
                }

                break;
            }

            jogging_or_not:
            if ( (prec->sevr > MINOR_ALARM) || (prec->mip != MIP_DONE) ||
                 (prec->spg != mmc100aSPG_Go)                               )
            {
                if      ( msta.Bits.RA_COMM_ERR     )
                    log_msg( prec, 0, "No jogging, hardware problem"  );
                else if ( msta.Bits.NOT_INIT        )
                    log_msg( prec, 0, "No jogging, init not finished" );
                else if ( prec->dmov != MIP_DONE    )
                    log_msg( prec, 0, "No jogging, motor is not idle" );
                else if ( prec->spg  != mmc100aSPG_Go )
                    log_msg( prec, 0, "No jogging, SPG is not Go"     );
                else
                    log_msg( prec, 0, "No jogging, unknown alarm"     );

                if ( fieldIndex == mmc100aRecordJOGF )
                {
                    prec->jogf = 0;
                    db_post_events( prec, &prec->jogf, DBE_VAL_LOG );
                }
                else
                {
                    prec->jogr = 0;
                    db_post_events( prec, &prec->jogr, DBE_VAL_LOG );
                }

                break;
            }

            prec->dmov = 0;
            if ( fieldIndex == mmc100aRecordJOGF )
            {
                prec->mip  = MIP_JOGF;

                if ( prec->dir == mmc100aDIR_Positive )
                    send_and_recv( mInfo, "J+", rbbuf );
                else
                    send_and_recv( mInfo, "J-", rbbuf );

                log_msg( prec, 0, "Jogging forward ..."  );
            }
            else
            {
                prec->mip  = MIP_JOGR;

                if ( prec->dir == mmc100aDIR_Positive )
                    send_and_recv( mInfo, "J-", rbbuf );
                else
                    send_and_recv( mInfo, "J+", rbbuf );

                log_msg( prec, 0, "Jogging backward ..." );
            }

            prec->poll = 1;
            mInfo->uEvent->signal();

            break;
        case mmc100aRecordCALF:
            if ( (prec->sevr > MINOR_ALARM) || (prec->mip != MIP_DONE) )
            {
                prec->calf = 0;
                break;
            }

            if ( prec->dir == mmc100aDIR_Positive ) new_px =   prec->calp;
            else                                  new_px = - prec->calp;

            goto start_calibration;
        case mmc100aRecordCALR:
            if ( (prec->sevr > MINOR_ALARM) || (prec->mip != MIP_DONE) )
            {
                prec->calr = 0;
                break;
            }

            if ( prec->dir == mmc100aDIR_Positive ) new_px = - prec->calp;
            else                                  new_px =   prec->calp;

            start_calibration:
            prec->osl  = prec->sl  ;
            prec->oex  = prec->rrbv;

            if ( prec->sl == mmc100aAble_Enable )
            {
                send_and_recv( mInfo, "SL=0", rbbuf );

                prec->sl   = 0;
                db_post_events( prec, &prec->sl,   DBE_VAL_LOG );

                epicsThreadSleep( 0.1 );
            }

            send_and_recv( mInfo, "PX=0", rbbuf );

            epicsThreadSleep( 0.1 );

            // send the move command
            sprintf( msg, "X%ld", new_px );
            send_and_recv( mInfo, msg,    rbbuf );

            prec->mip  = MIP_CAL1;
            prec->poll = 1;
            mInfo->uEvent->signal();

            if ( fieldIndex == mmc100aRecordCALF )
                log_msg( prec, 0, "Start calibration, fwd" );
            else
                log_msg( prec, 0, "Start calibration, rev" );

            break;
        case mmc100aRecordSPG :
            if ( (prec->spg == prec->oval) || (prec->mip == MIP_DONE) ) break;

            if ( prec->spg == mmc100aSPG_Go )
            {
                prec->mip &= ~( MIP_STOP | MIP_PAUSE );
                if ( prec->mip & MIP_JOG )
                {
                    log_msg( prec, 0, "Resume jogging" );

                    if ( prec->mip & MIP_JOGF )
                    {
                        if ( prec->dir == mmc100aDIR_Positive )
                            send_and_recv( mInfo, "J+", rbbuf );
                        else
                            send_and_recv( mInfo, "J-", rbbuf );
                    }
                    else
                    {
                        if ( prec->dir == mmc100aDIR_Positive )
                            send_and_recv( mInfo, "J-", rbbuf );
                        else
                            send_and_recv( mInfo, "J+", rbbuf );
                    }
                }
                else
                {
                    log_msg( prec, 0, "Resume moving"  );

                    sprintf( msg, "X%ld", prec->rval );
                    send_and_recv( mInfo, msg, rbbuf );
                }

                prec->poll = 1;
                mInfo->uEvent->signal();

                break;
            }
            else
            {
                if ( prec->spg == mmc100aSPG_Stop )
                {
                    log_msg( prec, 0, "Stop, with deceleration"  );
                    prec->mip &= ~MIP_PAUSE;
                    prec->mip |=  MIP_STOP ;
                }
                else
                {
                    log_msg( prec, 0, "Pause, with deceleration" );
                    prec->mip |=  MIP_PAUSE;
                }

                send_and_recv( mInfo, "STOP", rbbuf );
            }

            break;
        case ( mmc100aRecordSTOP ):
            prec->stop = 0;
        case ( mmc100aRecordESTP ):
            prec->estp = 0;

            if ( prec->mip == MIP_DONE ) break;

            prec->mip  &= ~MIP_PAUSE;
            prec->mip  |=  MIP_STOP ;
            if ( fieldIndex == mmc100aRecordSTOP )
            {
                send_and_recv( mInfo, "STOP",  rbbuf );

                log_msg( prec, 0, "Stop !!!" );
            }
            else
            {
                send_and_recv( mInfo, "ABORT", rbbuf );

                prec->spg = mmc100aSPG_Stop;
                db_post_events( prec, &prec->spg,  DBE_VAL_LOG );

                log_msg( prec, 0, "Emergency stop !!!" );
            }

            break;
        case ( mmc100aRecordDIR  ):
            if ( prec->dir == prec->oval ) break;

            if ( prec->dir == mmc100aDIR_Positive )
            {
                prec->llm = prec->off + prec->dllm;
                prec->hlm = prec->off + prec->dhlm;
            }
            else
            {
                prec->llm = prec->off - prec->dhlm;
                prec->hlm = prec->off - prec->dllm;
            }

            nval       = prec->lls;
            prec->lls  = prec->hls;
            prec->hls  = nval;
            if ( prec->lls != nval )
            {
                db_post_events( prec, &prec->lls,  DBE_VAL_LOG );
                db_post_events( prec, &prec->hls,  DBE_VAL_LOG );
            }

            nval       = prec->slrf;
            prec->slrf = prec->slrr;
            prec->slrr = nval;
            db_post_events( prec, &prec->slrf, DBE_VAL_LOG );
            db_post_events( prec, &prec->slrr, DBE_VAL_LOG );

            goto change_dir_off;
        case ( mmc100aRecordOFF  ):
            prec->llm += prec->off - prec->oval;
            prec->hlm += prec->off - prec->oval;

            change_dir_off:
            db_post_events( prec, &prec->llm,  DBE_VAL_LOG );
            db_post_events( prec, &prec->hlm,  DBE_VAL_LOG );

            prec->rbv  = prec->drbv * (1. - 2.*prec->dir) + prec->off;
            prec->val  = prec->rbv;

//          check_software_limits( prec );

            break;
        case mmc100aRecordSET :
            if ( (prec->set == prec->oval  ) ||
                 (prec->set == mmc100aSET_Set)    ) break;

            prec->rbv  = prec->val;
            if ( prec->foff == mmc100aOFF_Variable )
            {
                prec->off  = prec->rbv - prec->drbv * (1. - 2.*prec->dir);
                db_post_events( prec, &prec->off,  DBE_VAL_LOG );
            }
            else
            {
                new_dval    = (prec->rbv - prec->off) * (1. - 2.*prec->dir);
                prec->dllm += new_dval - prec->dval;
                prec->dhlm += new_dval - prec->dval;
                prec->rval  = NINT(new_dval / prec->eres);
                prec->dval  = new_dval;

                prec->px    = 0;

                sprintf( msg, "EX=%ld", prec->rval );
                send_and_recv( mInfo, msg,    rbbuf );

                epicsThreadSleep( 0.1 );
                send_and_recv( mInfo, "PX=0", rbbuf );

                db_post_events( prec, &prec->dllm, DBE_VAL_LOG );
                db_post_events( prec, &prec->dhlm, DBE_VAL_LOG );
            }

            if ( prec->dir == mmc100aDIR_Positive )
            {
                prec->llm = prec->off + prec->dllm;
                prec->hlm = prec->off + prec->dhlm;
            }
            else
            {
                prec->llm = prec->off - prec->dhlm;
                prec->hlm = prec->off - prec->dllm;
            }

            db_post_events( prec, &prec->llm,  DBE_VAL_LOG );
            db_post_events( prec, &prec->hlm,  DBE_VAL_LOG );

            mInfo->uEvent->signal();

            break;
        case mmc100aRecordLLM :
            if ( prec->llm > prec->hlm )           // illegal, restore old value
            {
                prec->llm  = prec->oval;
                db_post_events( prec, &prec->llm,  DBE_VAL_LOG );
                break;
            }

            if ( prec->dir == mmc100aDIR_Positive )
            {
                prec->dllm = prec->llm - prec->off;
                db_post_events( prec, &prec->dllm, DBE_VAL_LOG );
            }
            else
            {
                prec->dhlm = prec->off - prec->llm;
                db_post_events( prec, &prec->dhlm, DBE_VAL_LOG );
            }

            check_limit_violation:
            if ( (prec->val < prec->llm) || (prec->val > prec->hlm) )
                prec->lvio = 1;                   // set limit violation warning

            break;
        case mmc100aRecordHLM :
            if ( prec->hlm < prec->llm )           // illegal, restore old value
            {
                prec->hlm  = prec->oval;
                db_post_events( prec, &prec->hlm,  DBE_VAL_LOG );
                break;
            }

            if ( prec->dir == mmc100aDIR_Positive )
            {
                prec->dhlm = prec->hlm - prec->off;
                db_post_events( prec, &prec->dhlm, DBE_VAL_LOG );
            }
            else
            {
                prec->dllm = prec->off - prec->hlm;
                db_post_events( prec, &prec->dllm, DBE_VAL_LOG );
            }

            goto check_limit_violation;
        case mmc100aRecordDLLM:
            if ( prec->dllm > prec->dhlm )         // illegal, restore old value
            {
                prec->dllm = prec->oval;
                db_post_events( prec, &prec->dllm, DBE_VAL_LOG );
                break;
            }

            if ( prec->dir == mmc100aDIR_Positive )
            {
                prec->llm  = prec->off + prec->dllm;
                db_post_events( prec, &prec->llm,  DBE_VAL_LOG );
            }
            else
            {
                prec->hlm  = prec->off - prec->dllm;
                db_post_events( prec, &prec->hlm,  DBE_VAL_LOG );
            }

            goto check_limit_violation;
        case mmc100aRecordDHLM:
            if ( prec->dhlm < prec->dllm )         // illegal, restore old value
            {
                prec->dhlm = prec->oval;
                db_post_events( prec, &prec->dhlm, DBE_VAL_LOG );
                break;
            }

            if ( prec->dir == mmc100aDIR_Positive )
            {
                prec->hlm  = prec->off + prec->dhlm;
                db_post_events( prec, &prec->hlm,  DBE_VAL_LOG );
            }
            else
            {
                prec->llm  = prec->off - prec->dhlm;
                db_post_events( prec, &prec->llm,  DBE_VAL_LOG );
            }

            goto check_limit_violation;
        case mmc100aRecordERES:
            if ( prec->eres <= 0. )
            {
                prec->eres = prec->oval;
                db_post_events( prec, &prec->eres, DBE_VAL_LOG );
                break;
            }

            if ( prec->set == mmc100aSET_Use )
            {
                prec->drbv = prec->rrbv * prec->eres;
                prec->rbv  = (1. - 2.*prec->dir) * prec->drbv + prec->off;
                prec->val  = prec->rbv;
            }

            break;
        case mmc100aRecordVBAS:
            if ( prec->vbas > prec->vmax )
            {
                prec->vmax = prec->vbas;
                db_post_events( prec, &prec->vmax, DBE_VAL_LOG );

                sprintf( msg, "HSPD=%ld", prec->vmax );
                send_and_recv( mInfo, msg,    rbbuf );

                epicsThreadSleep( 0.1 );
            }

            sprintf( msg, "LSPD=%ld", prec->vbas );
            send_and_recv( mInfo, msg,    rbbuf );
        case mmc100aRecordVMAX:
            if ( prec->vmax < prec->vbas )
            {
                prec->vbas = prec->vmax;
                db_post_events( prec, &prec->vbas, DBE_VAL_LOG );

                sprintf( msg, "LSPD=%ld", prec->vbas );
                send_and_recv( mInfo, msg,    rbbuf );

                epicsThreadSleep( 0.1 );
            }

            sprintf( msg, "HSPD=%ld", prec->vmax );
            send_and_recv( mInfo, msg,    rbbuf );

            break;
        case mmc100aRecordACCL:
            sprintf( msg, "ACC=%d",   prec->accl );
            send_and_recv( mInfo, msg,    rbbuf );

            break;
        case mmc100aRecordDOUT:
            sprintf( msg, "DO=%d",    prec->dout );
            send_and_recv( mInfo, msg,    rbbuf );

            break;
        case mmc100aRecordEO  :
            sprintf( msg, "EO=%d",    prec->eo   );
            send_and_recv( mInfo, msg,    rbbuf );

            break;
        case mmc100aRecordPOL0:
        case mmc100aRecordPOL1:
        case mmc100aRecordPOL4:
        case mmc100aRecordENCM:
            sprintf( msg, "POL=%d",   prec->encm*256 + prec->pol4*16 +
                                      prec->pol1*2   + prec->pol0      );
            send_and_recv( mInfo, msg,    rbbuf );

            break;
        case mmc100aRecordSCV :
            sprintf( msg, "SCV=%d",   prec->scv  );
            send_and_recv( mInfo, msg,    rbbuf );

            break;
        case mmc100aRecordSL  :
            sprintf( msg, "SL=%d",    prec->sl   );
            send_and_recv( mInfo, msg,    rbbuf );

            if ( prec->sl == mmc100aAble_Disable )
            {
                strcpy( prec->sls, "Not Activated" );
                db_post_events( prec,  prec->sls , DBE_VAL_LOG );
            }

            break;
        case mmc100aRecordSLT :
            sprintf( msg, "SLT=%d",   prec->slt  );
            send_and_recv( mInfo, msg,    rbbuf );

            break;
        case mmc100aRecordSLE :
            sprintf( msg, "SLE=%d",   prec->sle  );
            send_and_recv( mInfo, msg,    rbbuf );

            break;
        case mmc100aRecordSLA :
            sprintf( msg, "SLA=%d",   prec->sla  );
            send_and_recv( mInfo, msg,    rbbuf );

            break;
        case mmc100aRecordSTUP:
            prec->stup = 0;
            mInfo->uEvent->signal();

            break;
        case mmc100aRecordCMD :
            status = send_and_recv( mInfo, prec->cmd, rbbuf );

            if ( status > 0 ) strncpy( prec->resp, rbbuf, 61 );
            else              strncpy( prec->resp, "",    61 );

            db_post_events( prec,  prec->resp, DBE_VAL_LOG );

            break;
        case mmc100aRecordRINI:
            init_motor( prec );

            prec->rini = 0;
            break;
    }

    if ( prec->val  != old_val  ) MARK( M_VAL  );
    if ( prec->dval != old_dval ) MARK( M_DVAL );
    if ( prec->rval != old_rval ) MARK( M_RVAL );
    if ( prec->px   != old_px   ) MARK( M_PX   );
    if ( prec->rbv  != old_rbv  ) MARK( M_RBV  );
    if ( prec->mip  != old_mip  ) MARK( M_MIP  );
    if ( prec->dmov != old_dmov ) MARK( M_DMOV );
    if ( prec->rcnt != old_rcnt ) MARK( M_RCNT );
    if ( prec->lvio != old_lvio ) MARK( M_LVIO );

    post_fields( prec, alarm_mask, 0 );
    post_msgs  ( prec                );

    return( 0 );
}

/******************************************************************************/
static long cvt_dbaddr( dbAddr *pDbAddr )
{
    mmc100aRecord *prec = (mmc100aRecord *)pDbAddr->precord;
    mmc100a_info  *mInfo = (mmc100a_info *)prec->dpvt;

    int          fieldIndex = dbGetFieldIndex( pDbAddr );
    long         status = 0;

    switch ( fieldIndex )
    {
        case mmc100aRecordLOGA:
        {
            pDbAddr->pfield         = (char *)prec->loga;
            pDbAddr->no_elements    = mInfo->mLength;
            pDbAddr->field_type     = DBF_CHAR;
            pDbAddr->field_size     = sizeof(char);
            pDbAddr->dbr_field_type = DBR_CHAR;
            break;
        }
        case mmc100aRecordLOGB:
        {
            pDbAddr->pfield         = (char *)prec->logb;
            pDbAddr->no_elements    = mInfo->mLength;
            pDbAddr->field_type     = DBF_CHAR;
            pDbAddr->field_size     = sizeof(char);
            pDbAddr->dbr_field_type = DBR_CHAR;
            break;
        }
        case mmc100aRecordLOGC:
        {
            pDbAddr->pfield         = (char *)prec->logc;
            pDbAddr->no_elements    = mInfo->mLength;
            pDbAddr->field_type     = DBF_CHAR;
            pDbAddr->field_size     = sizeof(char);
            pDbAddr->dbr_field_type = DBR_CHAR;
            break;
        }
        case mmc100aRecordLOGD:
        {
            pDbAddr->pfield         = (char *)prec->logd;
            pDbAddr->no_elements    = mInfo->mLength;
            pDbAddr->field_type     = DBF_CHAR;
            pDbAddr->field_size     = sizeof(char);
            pDbAddr->dbr_field_type = DBR_CHAR;
            break;
        }
        case mmc100aRecordLOGE:
        {
            pDbAddr->pfield         = (char *)prec->loge;
            pDbAddr->no_elements    = mInfo->mLength;
            pDbAddr->field_type     = DBF_CHAR;
            pDbAddr->field_size     = sizeof(char);
            pDbAddr->dbr_field_type = DBR_CHAR;
            break;
        }
        case mmc100aRecordLOGF:
        {
            pDbAddr->pfield         = (char *)prec->logf;
            pDbAddr->no_elements    = mInfo->mLength;
            pDbAddr->field_type     = DBF_CHAR;
            pDbAddr->field_size     = sizeof(char);
            pDbAddr->dbr_field_type = DBR_CHAR;
            break;
        }
        case mmc100aRecordLOGG:
        {
            pDbAddr->pfield         = (char *)prec->logg;
            pDbAddr->no_elements    = mInfo->mLength;
            pDbAddr->field_type     = DBF_CHAR;
            pDbAddr->field_size     = sizeof(char);
            pDbAddr->dbr_field_type = DBR_CHAR;
            break;
        }
        case mmc100aRecordLOGH:
        {
            pDbAddr->pfield         = (char *)prec->logh;
            pDbAddr->no_elements    = mInfo->mLength;
            pDbAddr->field_type     = DBF_CHAR;
            pDbAddr->field_size     = sizeof(char);
            pDbAddr->dbr_field_type = DBR_CHAR;
            break;
        }
    }

    return( status );
}

/******************************************************************************/
static long send_and_recv( struct mmc100a_info *mInfo, char const *msg, char *rbbuf )
{
    char         local_buf[MAX_MSG_SIZE];
    const double timeout = 1.0;
    size_t       nwrite, nread = 0;
    int          eomReason;
    asynStatus   asyn_rtn = asynError;

    sprintf( local_buf, "%s", msg );
    local_buf[strlen(msg)] = '\0';

    pasynOctetSyncIO->flush( mInfo->pasynUser );
    pasynOctetSyncIO->write( mInfo->pasynUser, local_buf, strlen(local_buf)+1,
                             timeout, &nwrite );

    asyn_rtn = pasynOctetSyncIO->read( mInfo->pasynUser, rbbuf, MAX_MSG_SIZE,
                                       timeout, &nread, &eomReason );

    if ( (asyn_rtn != asynSuccess) || (nread <= 0) )
    {
        rbbuf[0] = '\0';
        nread    = 0;
    }

    return( nread );
}

/******************************************************************************/
static void post_fields( mmc100aRecord *prec, unsigned short alarm_mask,
                                            unsigned short all )
{
    unsigned short  field_mask;
    changed_fields  cmap;

    cmap.All = prec->cmap;

    if ( (field_mask = alarm_mask | (all                  ? DBE_VAL_LOG : 0)) )
    {
        db_post_events( prec, &prec->vers, field_mask );
        db_post_events( prec,  prec->desc, field_mask );
        db_post_events( prec,  prec->usb,  field_mask );
        db_post_events( prec,  prec->asyn, field_mask );
        db_post_events( prec,  prec->dn,   field_mask );
        db_post_events( prec,  prec->fver, field_mask );
        db_post_events( prec,  prec->egu,  field_mask );
        db_post_events( prec, &prec->eres, field_mask );
        db_post_events( prec, &prec->dllm, field_mask );
        db_post_events( prec, &prec->dhlm, field_mask );
        db_post_events( prec, &prec->llm,  field_mask );
        db_post_events( prec, &prec->hlm,  field_mask );
    }

    if ( (field_mask = alarm_mask | (all | MARKED(M_VAL ) ? DBE_VAL_LOG : 0)) )
        db_post_events( prec, &prec->val,  field_mask );

    if ( (field_mask = alarm_mask | (all | MARKED(M_DVAL) ? DBE_VAL_LOG : 0)) )
        db_post_events( prec, &prec->dval, field_mask );

    if ( (field_mask = alarm_mask | (all | MARKED(M_RVAL) ? DBE_VAL_LOG : 0)) )
        db_post_events( prec, &prec->rval, field_mask );

    if ( (field_mask = alarm_mask | (all | MARKED(M_PX  ) ? DBE_VAL_LOG : 0)) )
        db_post_events( prec, &prec->px,   field_mask );

    if ( (field_mask = alarm_mask | (all | MARKED(M_RRBV) ? DBE_VAL_LOG : 0)) )
        db_post_events( prec, &prec->rrbv, field_mask );

    if ( (field_mask = alarm_mask | (all | MARKED(M_DRBV) ? DBE_VAL_LOG : 0)) )
        db_post_events( prec, &prec->drbv, field_mask );

    if ( (field_mask = alarm_mask | (all | MARKED(M_RBV ) ? DBE_VAL_LOG : 0)) )
        db_post_events( prec, &prec->rbv,  field_mask );

    if ( (field_mask = alarm_mask | (all | MARKED(M_DIFF) ? DBE_VAL_LOG : 0)) )
        db_post_events( prec, &prec->diff, field_mask );

    if ( (field_mask = alarm_mask | (all | MARKED(M_MIP ) ? DBE_VAL_LOG : 0)) )
        db_post_events( prec, &prec->mip,  field_mask );

    if ( (field_mask = alarm_mask | (all | MARKED(M_MOVN) ? DBE_VAL_LOG : 0)) )
        db_post_events( prec, &prec->movn, field_mask );

    if ( (field_mask = alarm_mask | (all | MARKED(M_DMOV) ? DBE_VAL_LOG : 0)) )
        db_post_events( prec, &prec->dmov, field_mask );

    if ( (field_mask = alarm_mask | (all | MARKED(M_RCNT) ? DBE_VAL_LOG : 0)) )
        db_post_events( prec, &prec->rcnt, field_mask );

    if ( (field_mask = alarm_mask | (all | MARKED(M_MISS) ? DBE_VAL_LOG : 0)) )
        db_post_events( prec, &prec->miss, field_mask );

    if ( (field_mask = alarm_mask | (all | MARKED(M_LVIO) ? DBE_VAL_LOG : 0)) )
        db_post_events( prec, &prec->lvio, field_mask );

    if ( (field_mask = alarm_mask | (all | MARKED(M_RLLS) ? DBE_VAL_LOG : 0)) )
        db_post_events( prec, &prec->rlls, field_mask );

    if ( (field_mask = alarm_mask | (all | MARKED(M_RHLS) ? DBE_VAL_LOG : 0)) )
        db_post_events( prec, &prec->rhls, field_mask );

    if ( (field_mask = alarm_mask | (all | MARKED(M_LLS ) ? DBE_VAL_LOG : 0)) )
        db_post_events( prec, &prec->lls,  field_mask );

    if ( (field_mask = alarm_mask | (all | MARKED(M_HLS ) ? DBE_VAL_LOG : 0)) )
        db_post_events( prec, &prec->hls,  field_mask );

    if ( (field_mask = alarm_mask | (all | MARKED(M_MSTA) ? DBE_VAL_LOG : 0)) )
        db_post_events( prec, &prec->msta, field_mask );

    if ( (field_mask = alarm_mask | (all | MARKED(M_SLS ) ? DBE_VAL_LOG : 0)) )
        db_post_events( prec,  prec->sls , field_mask );

    if ( (field_mask = alarm_mask | (all | MARKED(M_VELO) ? DBE_VAL_LOG : 0)) )
        db_post_events( prec, &prec->velo, field_mask );

    UNMARK_ALL;

    return;
}

/******************************************************************************/
static void update_status( struct mmc100a_info *mInfo )
{
    scanOnce( (struct dbCommon *)mInfo->precord );
}

/******************************************************************************/
static void checkStatus( struct mmc100a_info *mInfo )
{
    mmc100aRecord  *prec = mInfo->precord;
    char          rbbuf[MAX_MSG_SIZE];
    long          ps, px, ex, dsec, dnsec, status = OK;
    int           mst, sls, newData, retry;

    timespec      uTime;
    double        dtime;

    while ( ! interruptAccept ) epicsThreadSleep( 1 );

    while ( 1 )
    {
        newData = 1;

        // check the motor status MST
        retry = 1;
        do
        {
            status = send_and_recv( mInfo, "MST", rbbuf );
            if ( status > 0 )
            {
                status = sscanf( rbbuf, "%d", &mst );
                if ( status == 1 ) break;
            }

            epicsThreadSleep( 0.1 );
        } while ( retry++ < 3 );

        if ( status != 1 )                                 // failed to read MST
        {
            mst = -1;
            sls = -1;

            goto finished;
        }

        // check the StepNLoop status
        retry = 1;
        do
        {
            status = send_and_recv( mInfo, "SLS", rbbuf );
            if ( status > 0 )
            {
                status = sscanf( rbbuf, "%d", &sls );
                if ( status == 1 ) break;
            }

            epicsThreadSleep( 0.1 );
        } while ( retry++ < 3 );

        if ( status != 1 )                                 // failed to read SLS
        {
            mst = -1;
            sls = -1;

            goto finished;
        }

        clock_gettime( CLOCK_REALTIME, &uTime );

        dsec  = uTime.tv_sec  - mInfo->uTime.tv_sec;
        dnsec = uTime.tv_nsec - mInfo->uTime.tv_nsec;
        dtime = dsec + dnsec*1.e-9;
        if ( ((prec->sl == 1) && ((sls & 63) == 0)) ||
             ((prec->sl == 0) && ((mst &  7) == 0)) || (dtime >= 0.3) )
        {
            // read PS
            retry = 1;
            do
            {
                status = send_and_recv( mInfo, "PS", rbbuf );
                if ( status > 0 )
                {
                    status = sscanf( rbbuf, "%ld", &ps );
                    if ( status == 1 ) break;
                }

                epicsThreadSleep( 0.1 );
            } while ( retry++ < 3 );

            if ( status != 1 )                              // failed to read PS
            {
                mst = -1;
                sls = -1;

                goto finished;
            }

            // read PX
            retry = 1;
            do
            {
                status = send_and_recv( mInfo, "PX", rbbuf );
                if ( status > 0 )
                {
                    status = sscanf( rbbuf, "%ld", &px );
                    if ( status == 1 ) break;
                }

                epicsThreadSleep( 0.1 );
            } while ( retry++ < 3 );

            if ( status != 1 )                              // failed to read PX
            {
                mst = -1;
                sls = -1;

                goto finished;
            }

            // read EX
            retry = 1;
            do
            {
                status = send_and_recv( mInfo, "EX", rbbuf );
                if ( status > 0 )
                {
                    status = sscanf( rbbuf, "%ld", &ex );
                    if ( status == 1 ) break;
                }

                epicsThreadSleep( 0.1 );
            } while ( retry++ < 3 );

            if ( status != 1 )                              // failed to read EX
            {
                mst = -1;
                sls = -1;

                goto finished;
            }

            newData = 9;
        }

        finished:
        mInfo->uMutex->lock();

        mInfo->mst     = mst;
        mInfo->sls     = sls;
        mInfo->ps      = ps;
        mInfo->px      = px;
        mInfo->ex      = ex;

        mInfo->newData = newData;
        if ( newData == 9 )
        {
            mInfo->uTime.tv_sec  = uTime.tv_sec;
            mInfo->uTime.tv_nsec = uTime.tv_nsec;
        }

        mInfo->uMutex->unlock();

        callbackRequest( (CALLBACK *)mInfo );

        if ( prec->poll == 1 ) mInfo->uEvent->wait( prec->uint );
        else                   mInfo->uEvent->wait( 1          );
    }
}

/******************************************************************************/
static long log_msg( mmc100aRecord *prec, int dlvl, const char *fmt, ... )
{
    mmc100a_info  *mInfo = (mmc100a_info *)prec->dpvt;
    timespec     ts;
    struct tm    timeinfo;
    char         timestamp[40], msec[4], msg[512];

    va_list      args;

    if ( dlvl > max((int)prec->dlvl, (int)mmc100aRecordDebug) ) return( 0 );

    clock_gettime( CLOCK_REALTIME, &ts );
    localtime_r( &ts.tv_sec, &timeinfo );

    strftime( timestamp, 40, "%m/%d %H:%M:%S", &timeinfo );
    sprintf ( msec, "%03d", int(ts.tv_nsec*1.e-6 + 0.5) );

    va_start( args, fmt      );
    vsprintf( msg, fmt, args );
    va_end  ( args           );

    if ( dlvl <= prec->dlvl )
    {
        mInfo->lMutex->lock();

        if ( mInfo->cIndex > 0 )
        {
            if ( strncmp(mInfo->sAddr+mInfo->mLength*(mInfo->cIndex-1)+9,
                         msg, strlen(msg)                                )==0 )
                mInfo->cIndex--;
            else if ( mInfo->cIndex > 7 )
                memmove( mInfo->sAddr,
                         mInfo->sAddr+mInfo->mLength, mInfo->mLength*7 );
        }

        snprintf( mInfo->sAddr+mInfo->mLength*min(mInfo->cIndex,7), 61,
                  "%s %s", timestamp+6, msg );

        if ( mInfo->cIndex <= 7 ) mInfo->cIndex++;

        mInfo->newMsg = 1;

        mInfo->lMutex->unlock();
    }

    if ( dlvl <= mmc100aRecordDebug )
        printf( "%s.%s %s -- %s\n", timestamp, msec, prec->name, msg );

    return( 1 );
}

/******************************************************************************/
static void post_msgs( mmc100aRecord *prec )
{
    mmc100a_info  *mInfo = (mmc100a_info *)prec->dpvt;

    mInfo->lMutex->lock();

    if ( mInfo->newMsg == 0 )
    {
        mInfo->lMutex->unlock();
        return;
    }

    db_post_events( prec,  prec->loga, DBE_VAL_LOG );
    db_post_events( prec,  prec->logb, DBE_VAL_LOG );
    db_post_events( prec,  prec->logc, DBE_VAL_LOG );
    db_post_events( prec,  prec->logd, DBE_VAL_LOG );
    db_post_events( prec,  prec->loge, DBE_VAL_LOG );
    db_post_events( prec,  prec->logf, DBE_VAL_LOG );
    db_post_events( prec,  prec->logg, DBE_VAL_LOG );
    db_post_events( prec,  prec->logh, DBE_VAL_LOG );

    mInfo->newMsg = 0;
    mInfo->lMutex->unlock();

    return;
}

